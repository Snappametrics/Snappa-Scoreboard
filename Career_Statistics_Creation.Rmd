---
title: ""
output:
  html_document:
    df_print: paged
params:
   pwd: NULL
---
This notebook goes over the creation of our career statistics table
for the snappa scoreboard project. In this, we will explain the way in which we think about statistics in snappa, the concepts behind the statistics which we can collect with our current level of inputs, and the process to create the table. 


If you're just here to see the stats, you can jump to the <a href = "#The Current Offensive Leaderboard"> offensive leaderboard </a> the defensive leaderboard. 


This notebook is, like the project, a work in progress. Many of these values are subject to change as we iterate upon player input and expand the possibility of statistics that we can generate. 

## Our Approach to Snappa Statistics
In order to discuss what we can feasibly collect, it's necessary to establish how the various database tables work together under our current build of the app. Presented below are the tables as we have them here in R, but all of the tables which we collect during gameplay mirror their counterparts in the cloud. 

```{r, echo = F, include = F}
library(DBI)
library(RPostgres)
library(tidyverse)
library(gt)
library(askpass)
# Connect to the database
con <- dbConnect(RPostgres::Postgres(),
                          user = "postgres",
                          password = params$pwd,
                          host = "snappabase.cvoo4ewh2y4x.us-west-1.rds.amazonaws.com",
                          port = 5432,
                          dbname = "Snappa Scoreboard"
       )



# Pull the tables from the database and make them tibbles

players_tbl = tbl(con, "players") %>% collect()
scores_tbl = tbl(con, "scores") %>% collect()
game_stats_tbl = tbl(con, "game_stats") %>% collect()
game_history_tbl = tbl(con, "game_history") %>% collect()

# Generate the framework for the career stats table

career_stats = game_stats_tbl %>% left_join(players_tbl)


```

```{r echo = F}

# Present the column names


list("Players" = players_tbl, "Scores" = scores_tbl, 
     "Game Performance" = game_stats_tbl, "Game History" = game_history_tbl) %>% 
  imap_dfr(function(df, id) {
    columns = colnames(df)
    table_name = id
    tibble(table = table_name, 
                       variable = columns)
  }) %>% 
group_by(table) %>%
mutate(id = row_number()) %>%
pivot_wider(names_from = table,
            values_from = variable,
            id_cols = id) %>%
  select(-id)

# Using pivot wide to generate the output table at this point  
  
  
# What I want to do with this table eventually
#  gt(groupname_col = "table")
```

We organize the database according to 4 different "objects" in the usual sense of SQL database construction. 


1.`Players`  tracks the history of players whose names have been recorded in previous games


2. `scores` records all scoring events across all games and returns some simple logicals that give us details about the nature of the point scored (e.g. whether or not it was a paddle) 


3. `Game Performance` aggregates data from the `Scores` table, recording performance by game and player. 


4. `Game History`, as the name suggests, provides us with the history of games and some high-level descriptions of the game, like who won and when the game was played.      

For more information on what a paddle is and how players can score points in a game of snappa, consult the Snappa Scoreboard Wiki page on "An Overview of SnappaMetrics" [here](https://github.com/mdewey131/Snappa-Scoreboard/wiki/An-Overview-of-SnappaMetrics). Together, `Players` and `Scores` are the tables which handle the data being streamed in to the app during play. 

The `Career Statistics` table primarily uses `Players` and `Game Performance` to generate the statistics of interest. 

Having established all of this, we can now move on to the creation of the variables which we use in the career statistics table, divided by whether they are defensive or offensive in nature. Offensive statistics refer to the player's ability to generate points as the direct result of a shot that they throw, by which we mean that offense tracks points that weren't denied by catches or paddles. Because the inputs for the Snappa Scoreboard are largely centered around offense, this is the easier of the two categories to track.

We generate statistics for offense which we think will be interesting and which we can reliably recover from the data that we have. This second point is crucial- we believe that a deep world of statistical measures exists for snappa (something I lovingly call "Snappametrics"), but we do not currently have all of the tools necessary to collect them. This is also why the section on defense will have less statistics than those on offense.

Having said all of this, let's proceed to the statistics.








### The Current Offensive Leaderboard

```{r echo = F}


who_won = scores_tbl %>% 
            group_by(game_id) %>%
            summarize(total_a = su
# Update missing values that are in game_stats_tbl
missings = scores_tbl %>%
            group_by(player_id, game_id) %>% 
              summarise(total_points = sum(points_scored),
                        shots = case_when(
                              # People on team A
                                  any(str_detect(last(round_num), "A" & shooting = T ),
                                      str_detect(last(round_num) "B" & shooting = F)) ~
                                        max(as.integer(str_sub(round_num, end = -2, start = -3))),
                              # People on team B. This one is harder because I have to look at which team won
                      
                      points_per_round = case_when(
                                              str_detect(pull(
                                                filter(
                                                  snappaneers(),p layer_name == input$scorer
                                                  ),
                                                team), "a"
                                                ) ~ sum(points_scored) / ceiling(vals$shot_num/2),
                                              str_detect(
                                                pull(
                                                  filter(
                                                    snappaneers(), player_name == input$scorer
                                                    ), 
                                                  team), "b"
                                                ) ~ sum(points_scored) / floor(vals$shot_num/2)),
                ones = sum((points_scored == 1)),
                twos = sum((points_scored == 2)),
                threes = sum((points_scored == 3)),
                impossibles = sum((points_scored > 3)))
    




career_stats %>%
  group_by(player_id) %>%
  summarise(`Name` = unique(player_name),
            `Lifetime Points` = sum(total_points, na.rm = T),
            `Games Played` = length(game_id),
            `Lifetime Ones` = sum(ones, na.rm = T),
            `Lifetime Clinks` = sum(twos, na.rm = T),
            `Lifetime Sinks` = sum(threes, na.rm = T),
            `Lifetime Impossibles` = sum(impossibles, na.rm = T),
            `Paddle Points` = sum(paddle_points, na.rm = T),
            `Lifetime Points Per Round` = `Lifetime Points`/sum(shots, na.rm = T),
            `Offensive Points Per Round` = (`Lifetime Points` - `Paddle Points`)/ sum(shots, na.rm = T),
            `Defensive Points Per Round` = sum(paddle_points)/sum(shots, na.rm = T),
            `Toss Efficiency` = sum(sum(ones, na.rm = T), 
                                  sum(twos, na.rm = T), 
                                  sum(threes, na.rm = T), 
                                  sum(impossibles, na.rm = T))/sum(shots, na.rm = T)) %>%
  select(-player_id)
  


```

```{js include = F, echo = F}
  // Allows me to link to headers
  // When the document is fully rendered...
  $(document).ready(function() {
    // ...select all header elements...
    $('h1, h2, h3, h4, h5').each(function() {
      // ...and add an id to them corresponding to their 'titles'
      $(this).attr('id', $(this).html());
    });
  });
```









